# import os
# if os.getcwd().split("/")[-1] == "scripts":
#     os.chdir('..')
# print(os.getcwd())

import time
import numpy as np
import pandas as pd
from scipy import stats
import argparse

# prepare logging
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

from neurolib.utils.parameterSpace import ParameterSpace
from neurolib.optimize.evolution import Evolution

from scandy.models.ObjectModel import ObjectModel
from scandy.models.LocationModel import LocationModel
from scandy.utils.dataclass import Dataset


if __name__ == "__main__":

    starttime = time.time()

    # load VidCom dataset
    datadict = {
        "PATH": "/scratch/nroth/VidCom/VidCom/",
        "FPS": 30,
        "PX_TO_DVA": 0.06,
        "FRAMES_ALL_VIDS": 300,
        "gt_foveation_df": "2021-12-04_VidCom_GT_fov_df",
        "gt_fovframes_nss_df": "gt_fovframes_nss_df.csv",
        "trainset": [
            "dance01",
            "dance02",
            "garden06",
            "garden07",
            "park01",
            "park06",
            "road02",
            "road05",
            "room01",
            "walkway03",
        ],
        "testset": [
            "field03",
            "foutain02",
            "garden04",
            "garden09",
            "park09",
            "road04",
            "robarm01",
            "room02",
            "room03",
            "tommy02",
            "uscdog01",
            "walkway01",
            "walkway02",
        ],
    }

    VidCom = Dataset(datadict)
    # get current local time and date
    timestamp = time.strftime("%Y-%m-%d-%HH-%MM-%SS", time.localtime())

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--Ninit", default=64, type=int, help="initial population size for evolution"
    )
    parser.add_argument(
        "--Npop", default=32, type=int, help="population size for each generation"
    )
    parser.add_argument("--Ngen", default=50, type=int, help="number of generations")
    parser.add_argument(
        "--featureset", default="molin", type=str, help="molin, TASEDnet, or None"
    )
    parser.add_argument(
        "--name", default="", type=str, help="Add in front of name string"
    )
    parser.add_argument(
        "--model",
        default="obj",
        type=str,
        help="obj or loc, will initiallize respective model subclass",
    )
    parser.add_argument(
        "--videos",
        default="train",
        type=str,
        help="train, or all (or individual video)",
    )
    parser.add_argument(
        "--fitnessFovCat",
        default=False,
        action="store_true",
        help="If set to True, this will use the ratio of foveation categories in addition to dur&amp statistics.",
    )
    parser.add_argument(
        "--jobID", default=None, help="HPC slurm job ID (generated by SBATCH)"
    )
    args = parser.parse_args()

    N_init = args.Ninit
    N_pop = args.Npop
    N_gen = args.Ngen
    NAME = args.name
    MODEL = args.model
    FEATURESET = args.featureset
    VIDEOS = args.videos
    fitnessFovCat = args.fitnessFovCat
    job_id = args.jobID
    if fitnessFovCat:
        namestr = f"{NAME}{MODEL}_{VIDEOS}_{FEATURESET}_wFovCat_{N_init}-{N_pop}-{N_gen}_{timestamp}_{job_id}"
    else:
        namestr = f"{NAME}{MODEL}_{VIDEOS}_{FEATURESET}_{N_init}-{N_pop}-{N_gen}_{timestamp}_{job_id}"
    print(namestr)

    # evaluate dur & amp for the fitness function
    if VIDEOS == "all":
        gt_amp_dva = VidCom.gt_foveation_df["sac_amp_dva"].dropna().values
        gt_dur_ms = VidCom.gt_foveation_df["duration_ms"].dropna().values
        gt_fovcats = VidCom.get_fovcat_ratio().values()
    elif VIDEOS == "train":
        gt_amp_dva = VidCom.train_foveation_df["sac_amp_dva"].dropna().values
        gt_dur_ms = VidCom.train_foveation_df["duration_ms"].dropna().values
        gt_fovcats = VidCom.get_fovcat_ratio("train").values()
    elif VIDEOS in VidCom.used_videos:
        df_gtvid = VidCom.gt_foveation_df[VidCom.gt_foveation_df["video"] == VIDEOS]
        gt_amp_dva = df_gtvid["sac_amp_dva"].dropna().values
        gt_dur_ms = df_gtvid["duration_ms"].dropna().values
        gt_fovcats = VidCom.get_fovcat_ratio(VIDEOS).values()
    else:
        raise Exception(
            f"videos flag should be all, train, or sgl_vid, but is {VIDEOS}!"
        )

    def optimize_me(traj):
        ind = evolution.getIndividualFromTraj(traj)
        if MODEL == "obj":
            model = ObjectModel(VidCom)
        elif MODEL == "loc":
            model = LocationModel(VidCom)
        else:
            raise Exception(f"The only implemented models so far are obj and loc!")
        model.params["centerbias"] = "anisotropic_default"
        model.params["featuretype"] = FEATURESET
        # free model parameters, varied in evolution
        model.params["ddm_thres"] = ind.ddm_thres
        model.params["ddm_sig"] = ind.ddm_sig
        model.params["att_dva"] = ind.att_dva
        model.params["ior_decay"] = ind.ior_decay
        # IOR parameters depend on the model...
        if MODEL == "obj":
            model.params["ior_inobj"] = ind.ior_inobj
        else:
            model.params["ior_dva"] = ind.ior_dva

        # run model for all videos for 12 seeds, results stored in class attribute
        #   seed==0 means no seed --> not reproducable, always start with 1!
        model.run(VIDEOS, seeds=[s for s in range(1, 13)])

        # for the fitness it is sufficient to look into dfov, no need to evaluate!
        # model.evaluate_all_to_df()  # creates obj.result_df
        # sim_dur_ms = model.result_df["duration_ms"].dropna().values
        # sim_amp_dva = model.result_df["sac_amp_dva"].dropna().values
        # make sure that fitness can be calculated even without a saccade
        # if not sim_amp_dva.size:
        #     sim_amp_dva = [0]  # leads to worst fitness...
        sim_dur_ms, sim_amp_dva = model.get_all_dur_amp()

        # evaluate fitness
        ks_amp, p_amp = stats.ks_2samp(gt_amp_dva, sim_amp_dva)
        ks_dur, p_dur = stats.ks_2samp(gt_dur_ms, sim_dur_ms)
        if fitnessFovCat:
            model.evaluate_all_to_df()
            fovcat_dist = np.sum(
                np.abs(
                    np.array(list(model.get_fovcat_ratio().values())) - list(gt_fovcats)
                )
            )
            fitness_tuple = (ks_dur, ks_amp, fovcat_dist)

            # return how often BDIR events occur (not only the time for each, which is what get_fovcat_ratio does)
            fovcount_dict = model.result_df["fov_category"].value_counts().to_dict()
            # make sure that all categories are in dict!
            for key in ["B", "D", "I", "R"]:
                if key not in fovcount_dict:
                    fovcount_dict[key] = 0

            store_dict = {
                "fov_cat": np.array(list(model.get_fovcat_ratio().values())),
                "fov_cat_number": [fovcount_dict[cat] for cat in ["B", "D", "I", "R"]],
                "nss_score_videos_with_std": np.array(
                    list(model.evaluate_nss_scores().values())
                ),
            }

        else:
            fitness_tuple = (ks_dur, ks_amp)
            store_dict = {}


        print(
            f"DEBUG ({round((time.time() - starttime)/60,1)}m = {round((time.time() - starttime)/60/60,2)}h):"
            f"results in ks_dur:{ks_dur}, with p={p_dur}, ks_amp:{ks_amp}, with p={p_amp}"
        )

        return fitness_tuple, store_dict

    if MODEL == "obj":
        pars = ParameterSpace(
            ["ddm_thres", "ddm_sig", "att_dva", "ior_decay", "ior_inobj"],
            [[1.5, 3.5], [0.05, 0.25], [5, 20], [30, 300], [0.4, 1.0]],
        )
    else:
        pars = ParameterSpace(
            ["ddm_thres", "ddm_sig", "att_dva", "ior_decay", "ior_dva"],
            [[1.0, 3.0], [0.005, 0.05], [3, 15], [30, 300], [0.5, 10]],
        )

    if fitnessFovCat:
        weightList = [-1.0, -1.0, -1.0]
    else:
        weightList = [-1.0, -1.0]
    evolution = Evolution(
        optimize_me,
        pars,
        weightList=weightList,
        filename=f"{namestr}.hdf",
        POP_INIT_SIZE=N_init,
        POP_SIZE=N_pop,
        NGEN=N_gen,
    )

    evolution.run(verbose=True)

    EVOLUTION_DILL = f"{namestr}.dill"
    evolution.saveEvolution(EVOLUTION_DILL)
